写给CS人的泛函书

（先得报一下进度：看完了前三章，前两章的习题大部分都做了，不过第三章就偷懒几乎没做）

如果要问现代数学最重要的概念是什么，那毫无疑问就是函数了，或者更确切地说，是映射。泛函这个词，或许对非数学系的同学来说有些陌生，但如果写成英语 functional, 看起来就眼熟多了。狭隘一点地说，泛函就是以函数为参数，返回值是数值的一类函数。看到这里相信不少同学都发现了，这就是在很多语言中被称为高阶函数（high-order function）的那个东西。泛函在数学中是如此普遍的概念，现代数学几乎无处不会用到。数学家们很自然地在集合上添加运算，构造空间；从一个空间映射到另一个空间，创造泛函。对泛函做变换，构造泛函的泛函。等等。

为什么我要在这里提到数学和泛函？因为在我看来， lisp 是一门以表达数学为己任的语言。正如 SICP 中希望表达的一种观点：语言会影响思维。如果数学推理过程中最频繁应用到的泛函，在计算机语言中却没有对应的表达，换言之数学思维不能很自然地表述为计算机语言的话，那么计算机对于数学研究的意义就显得很可疑了，毕竟那时候的计算机可不是用来玩大菠萝3的。所以这里就有了两拨人，务实的一拨人开发出了 fortran ，力主解决数值计算；务虚的一拨人则yy出了 lisp ，试图一举解决符号计算的难题。在 John McCarthy 所作的 history of lisp 中这样写到：
Then mathematical neatness became a goal and led to pruning some features from the core of the language.（保证数学上的简洁性成为我们的目标，并因此使得一些特性没有加入到语言核心内。）
This was partly motivated by esthetic reasons and partly by the belief that it would be easier to devise techniques for proving programs correct if the semantics were compact and without exceptions.（这部分是基于美学上的考虑，部分是因为我们相信，紧凑而没有特例的语法才更有可能设计出一种从数学上证明程序正确的方法。）

扯得太远了，毕竟这是一篇书评，还是需要回到书的正题上来。之所以讲了这么多关于数学和历史的东西，是因为我觉得在看这本书前，最重要的是理解： lisp 是什么。而我又一直相信理解一样事物最好的办法就是理解其历史。（顺带说一句，以上历史都是在看过书以后才找的，所以也是我的血泪教训……）如上所示， lisp 是一门为了表达数学推导过程而诞生的语言，所以不可避免地使得 SICP 前两章的例子几乎全是数学问题。代码只是其形，而其神是纯粹的数学。所以这里似乎就陷入了一种两难的境地：如果执意于写代码的话，那看起来做的都是形而下的工作；而如果只思考问题的数学原理的话，那姑且不说是舍本逐末，至少也是偏离主题了。在看完 SICP 以后我始终怀着这种疑问而不解——看的时候是不会有这种感觉的，因为注意力全部纠结于书中的题目了——不过在写这篇书评时又翻了一下第一章，似乎明白了。

小节1.1写到：
"一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。"
"每一种强有力的语言都为此提供了三种机制：基本表达形式，组合的方法，抽象的方法"

所以我认为 SICP 这本书最主要的目的，就是"教你用 lisp 的语言，来组织，来抽象，来表达想法"。从这个意义上来说， SICP 和一本 Learning Python ，或者一本 C Programming Language 并没有太多的区别，依然讲授的是"用特定的语言求解特定的问题"。不过略有不同的是， lisp 太特殊了，导致从 c 转向 python 或许不需要太多的思维转换，但从 c 转向 lisp 却需要对思维习惯大改造一番，这我想就是 SICP 地位如此之高的原因吧。我也同意，学习 SICP 确实很锻炼思维，以及培养一种更加高度的抽象习惯，但是从功利意义上来说这是否是"有用"的？我不敢肯定，因为我只是个学习cs不过一年的菜鸟。其实在看 SICP 的过程中，很多时候我都会感慨，"如果我不是数学系的，这一段到底会怎么理解呢"。一个典型例子就是习题2.6，初看我也一头雾水，后来才意识到 zero 是 f->id 的泛函，正是零映射， one 是 f->f 的泛函，正是恒同映射，也就是函数空间的1。如果没有学过泛函分析的我来看这道题目，估计只能好不容易推导出规律后，感慨于 Church 计数的"巧妙"了。所以从好的层面来看， SICP 至少能够带来泛函的直观感受，因此我才说 SICP 是一本写给CS人的泛函数。但是从坏的层面上说，数学抽象毕竟是象牙塔里的产物，当好不容易抽象出一个优雅的模型却发现手头的语言难以表达或者效率上有种种顾虑的时候，还是很郁闷的吧。

前面貌似说了 SICP 的不少坏话，其实只是想拉低一下 SICP 的评价，至少使得后人不至于期待过高。 SICP 是一本好书，至少是一本有趣的书，这点我是非常赞同的。就冲着她那创意的封面图和作者头像，每章开篇都会引用一段（非常利于装逼）的名言，以及用半页的篇幅讲述和主题完全无关的 MIT 第一任校长的生平，想不有趣都难啊。不过我还是世俗一下，列一下自己看过这本书以后比较"现实"的收获：
1.对于构造递归式的训练。相信做过的都深有体会……
列表处理流程，也就是 map-filter-reduce 。
3.流处理这一节让我终于明白了 generator 的意义。
最后说一下习题，习题的重要性想来大家都很清楚。不过对于 SICP 来说，我觉得习题未必都要写成代码，在纸上写出思路和关键代码也未为不可。因为 scheme 的编码效率实在不高（就是 scheme 逼得我给 vim 装上 surround 插件……），而习题重要的还是整个抽象的过程。另外就是，要找个好一点的解释器，我下了 MIT 的 scheme 解释器发现各种操作太不人性了……
